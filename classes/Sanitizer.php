<?php

namespace sgkirby\Commentions;

use Parsedown;
use HTMLPurifier;
use HTMLPurifier_AttrDef;
use HTMLPurifier_Config;
use Kirby\Cms\Dir;

class Sanitizer
{
    const HTML_PURIFIER_ALLOWED_HTML = [
        '*[lang|dir]',
        'a[rel|href]',
        'abbr[title]',
        'b',
        'blockquote', // [cite]
        'br',
        'cite',
        'code[class]',
        'del', // [cite|datetime]
        'kbd',
        'mark',
        'em',
        'i',
        'ins',// [cite|datetime]
        'li', // [value]
        'ol', // [reversed|start|type] attributes disabled, as they could easily collide with page styles
        'p',
        'pre[class]',
        'q', // [cite]
        // 'ruby',
        // 'rb',
        // 'rp',
        // 'rt',
        // 'rtc',
        // 'u',
        // 's',
        // 'strike',
        'strong',
        'ul',
    ];

    const HTML_PURIFIER_ALLOWED_REL_ATTR = [
        'noopener',
        'noreferrer',
        'nofollow',
    ];

    /**
     * Cached instance of HTML Purifier instance used for processing
     *
     * @var HTMLPurifier
     */
    protected static $purifier;

    /**
     * Cached instance of the Parsedown Markdown parser
     *
     * @var Parsedown
     */
    protected static $parsedown;


    /**
     * Converts untrusted HTML/Markdown input into sanitized, safe HTML code.
     *
     * @param string $text The input text, expecting "dirty" HTML code and/or Markdown
     * @return string The cleaned-up/"purified" text.
     */
    public static function markdown(string $text, ?bool $smartypants = null): ?string
    {
        if (static::$parsedown === null) {
            // Using the raw Parsedown library directly instead of
            // Kirbyâ€™s Markdown component to have full control over the settings.
            static::$parsedown = new Parsedown();
            static::$parsedown->setBreaksEnabled(true);
        }

        if (static::$purifier === null) {

            // Create a cache directory, that HTMLPurifier uses
            // for storing serizalized definitions.
            $cacheRoot = kirby()->root('cache') . '/commentions/htmlpurifier';
            Dir::make($cacheRoot);

            $config = HTMLPurifier_Config::createDefault();
            $config->set('Attr.AllowedRel', static::HTML_PURIFIER_ALLOWED_REL_ATTR);
            // $config->set('Attr.DefaultTextDir', $dir);
            $config->set('AutoFormat.Linkify', true);
            $config->set('HTML.Allowed', implode(',', static::HTML_PURIFIER_ALLOWED_HTML));
            $config->set('URI.DisableExternalResources', true);
            $config->set('URI.DisableResources', true);
            $config->set('Output.Newline', "\n"); // Use unix line breaks only ðŸ¤˜
            $config->set('Cache.SerializerPath', $cacheRoot);

            // Add HTMl5-only elements to the HTML definition, otherwise
            // the purifier would refuse to accept them.
            $def = $config->getHTMLDefinition(true);
            $def->addElement('mark', 'Inline', 'Inline', 'Common');

            // Our sanitized code should not contain any classes in the end,
            // with the exception of codeblocks, as generated by a markdown
            // formatting tool, such as Parsedown.

            // The class attribute is allowed on the pre element, but
            // its value can only be `code`.
            $def->addAttribute('pre', 'class', 'Enum#code');

            // The code element only accepts a class name in the format
            // `language-*`, that is used by JavaScript-based syntax
            // highlighters for determing a code blockâ€™s language.
            $def->addAttribute('code', 'class', new class extends HTMLPurifier_AttrDef {
                public function validate($string, $config, $context) {
                    return preg_match('/^language-[a-z0-9]+$/', $string) === 1;
                }
            });

            static::$purifier = new HTMLPurifier($config);
        }

        // Parse Markdown first
        $text = static::$parsedown->text($text);

        if ($smartypants ?? option('smartypants')) {
            // Only apply smartypants filter, if enabled in Kirby
            $text = smartypants($text);
        }

        return static::$purifier->purify($text);
    }
}
